
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    
    
    <head>
        <title>Animación por Computador — Tema 1</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
            
         <!-- Fonts and stuff -->
         <link href="matlab-highlighter-1.55.css" rel="stylesheet" type="text/css">
         <script src="matlab-highlighter-1.55.min.js"></script>
         <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,800italic,400,700,800" rel='stylesheet' type='text/css'>
         <link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
                
        </head>
                
        <body onload="highlightMATLABCode();">
            <div id="content">
            <div id="content-inner">
                
                <div class="section head">
                    <h1>Slides</h1>
                </div>
                <div class="section abstract" >
                    1.1 — <a href="docs/1.1-Interpolacion-v2016.pdf">Interpolación </a><br/>
                    1.2 — <a href="docs/1.2-Movimiento-a-traves-de-una-curva-v2016.pdf">Movimiento a través de una curva </a><br/>
                    1.3 — <a href="docs/1.3-Sistemas-Keyframe.pdf">Sistemas keyframe </a><br/><br/>
                    2.1 — <a href="docs/2.1-Cinematica-directa-v2016.pdf">Cinemática directa</a><br/>
                    2.2 — <a href="docs/2.2-Cinematica-inversa-v2016.pdf">Cinemática inversa</a><br/>
                </div>
            <div class="section head">
                <h1>Tema 1.1 — Interpolación</h1>
                
                <div class="authors">
                Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                <div class="venue"></div>
                
            </div>
            <!--
            <div class="section teaser">
            <iframe width="640" height="360" src="https://www.youtube.com/embed/?" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
            <p style="font-size:11px; text-align:center">
            <a href="content/>.mp4" target="_blank">Download Video</a>
            </p>
            </div>
            -->
        
            <div class="section abstract" >
                <h2>Ejercicio 1.1.1</h2>
                <p>
                    Escribe una función de MATLAB para visualizar los polinomios base de Hermite de grado 3.
                    <pre class="matlab-code">
function plot_hermite_basis()
    figure;
    hold on;
    grid on;
                
    % Rango
    x = 0:0.0001:1;
                
    H0 = 2*x.^3 - 3*x.^2 +1 ;
    plot(x,H0);

    % Completar...
    
    hold off;
end                    </pre>
                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="soluciones/plot_hermite_basis.m">Solución</a>
                </p>
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.1.2</h2>
                <p>
                Calcula el polinomio de Hermite <code>P(x)</code> tal que <code>P(0) = 1</code>, <code>P(1) = 1</code>, <code>P'(0) = 0</code>, <code>P'(1) = 1</code>. Implementa una función en MATLAB para visualizar el resultado.
                    <pre class="matlab-code">
function hermite_interpolation_demo()
    figure;
    hold on;
    x = [0,1];
    y = [1,1];
                    
    % Completar
                    
    plot(x,y);
    hold off;
end</pre>
                    <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="soluciones/hermite_interpolation_demo.m">Solución</a>
                </p>
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 1.1.3</h2>
                <p>
                Calcula el polinomio interpolador de Lagrange de la siguiente tabla. Escribe una función de MATLAB que dibuje cada uno de los polinomios interpoladores y el polinomio resultante.
                </p>
                
                <code>
                    x -9  -4  -1   7<br/>
                    y  5   2  -2   9<br/>
                </code>
                <br/>
                <p>
                El resultado debe ser algo parecido a <a href="ejercicio3.png">esto</a>.
                
                
                ¿Cuál es el valor del primer polinomio interpolador en <code>x=-4</code>, <code>x=-1</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del segundo polinomio interpolador en <code>x=-9</code>, <code>x=-1</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del tercer polinomio interpolador en <code>x=-9</code>, <code>x=-4</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del cuarto polinomio interpolador en <code>x=-9</code>, <code>x=-4</code> y <code>x=-1</code>?
                <br/><br/>
                 <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="soluciones/lagrange_interpolation_demo.m">Solución</a>
                </p>
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.1.4</h2>
                <p>
                Interpolar y dibujar en MATLAB con splines lineales la función <code>f(x) = 1 / x</code> en los puntos en los que  <code>x</code> vale <code>1, 2 y 4</code>.
                <br/><br/>
                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="soluciones/linear_spline_interpolation.m">Solución</a>
                </p>
                
            </div>

            <div class="section abstract" >
                <h2>Ejercicio 1.1.5</h2>
                <p>
                Interpolar y dibujar en MATLAB  con splines quadráticas (grado 2) la función <code>f(x)</code> que pasa por los puntos <code>f(3) = 2.5; f(4.5) = 1;  f(7) = 2.5; f(9)=0.5</code>. Utiliza la función de MATLAB <code>X = linsolve(A,b)</code> para resolver el sistema de ecuaciones.
                <br/><br/>
                Se trata de un sistema indeterminado, con más incognitas que ecuaciones. ¿Qué se puede hacer en estos casos? Calcula por lo menos 2 posibles soluciones del sistema, y dibuja las splines resultantes en MATLAB.
                <br/><br/>
                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="soluciones/quadratic_spline_interpolation.m">Solución</a>
                </p>
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 1.1.6</h2>
                <p>
                Utilizando como referencia la función <code>bezier_linear()</code> de más abajo que dibuja una <curva> de Bezier de con sólo dos puntos de control, escribe dos nuevas funciones <code>bezier_quadratic()</code> y <code>bezier_cubic()</code> que calculen y dibujen curvas cuadráticas y cúbicas.
                    <br/>
                    <br/>
                    Modifica el tercer parámetro de la función <code>linspace</code> y observa como cambian las curvas dibujadas. ¿Qué controla este parámetro?
                <pre class="matlab-code">
function placelabel(pt,str)
    x = pt(1);
    y = pt(2);
    h = line(x,y);
    h.Marker = '*';
    h = text(x,y,str);

    h.HorizontalAlignment = 'center';
    h.VerticalAlignment = 'bottom';
end
                </pre>
                
<pre class="matlab-code">
function bezier_linear()
    figure;
    hold on
    pt1 = [ 5;-10];
    pt2 = [45; 15];

    placelabel(pt1,'  pt_1');
    placelabel(pt2,'  pt_2');
    xlim([0 50])
    axis equal

    % Crea un vector de 100 valores equidistantes entre 0 y 1
    t = linspace(0,1,100);
    % Evalua la funcion (1-t) * pt1 + t * pt2 en todos los puntos t
    pts = kron((1-t),pt1) + kron(t,pt2);
    %plot(pts(1,:),pts(2,:))

    % Metodo alternativo
    %pts = [];
    %for t=0:0.2:1
    %    pts = [pts ((1-t) * pt1 + t * pt2)];
    %end

    plot(pts(1,:), pts(2,:));

    hold off;
end
</pre>
                </p>
                
            </div>
            
            <div class="section head">
                <h1>Tema 1.2 — Movimiento a través de una curva</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.2.1</h2>
                <p>
                Escribe una funcion en MATLAB llamada <code>compute_arc_length_cubic_bezier(pt1, pt2, pt3, pt4, samples)</code> que calcule mediante <i>Forward Differencing</i> la longitud del arco de una curva cúbica de Bezier. ¿Cómo cambia el resultado en función del parámetro <code>samples</code>?
                </p>
                
                <h2>Ejercicio 1.2.2</h2>
                <p>
                Escribe una función en MATLAB que dados 4 puntos de control, calcule su curva de Bezier y marque sobre ella: puntos equidistantes con respecto el parámetro <code>t</code> (tiempo) y con respecto el parámetro <code>s</code> (longitud del arco). El resultado final debería ser parecido a <b><a href="trivial-VS-constant.png">esto</a></b>.
                </p>

                <h2>Ejercicio 1.2.3</h2>
                <p>
                ¿Qué condiciones tienen que darse para que una curva formada por 2 curvas de Bezier tenga continuidad C<sup>0</sup>? ¿Y C<sup>1</sup>?
                </p>
                <p>
                Dibuja en MATLAB un curva cerrada con continuidad C<sup>1</sup> creada por 4 curvas cúbicas de Bezier. Utiliza transformaciones del tipo translación y escalado en los puntos de control para cambiar el tamaño la curva dibujada. <b><a href="bezier-joint.png">Aquí</a></b> tienes un ejemplo del tipo de resultado que puedes conseguir.
                </p>
                
            </div>
            
            <div class="section head">
                <h1>Tema 2.1 — Cinemática directa</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 2.1.1</h2>
                <p>
Desarrolla la función <code>plot_skeleton(skeleton, rots) </code>en MATLAB que dibuje mediante la técnica de Cinemática Directa la estructura jerárquica inicializada a continuación.
<pre class="matlab-code">
function skeleton_demo()
    close all;

    trans0 = [0,0];
    trans1 = [-1,-1]; % Offset con respecto joint 0
    trans2 = [0,-1];  % Offset con respecto joint 1
    trans3 = [0,-1];  % Offset con respecto joint 2

    rot1 = 0;         % Rotacion local del joint 0
    rot2 = 0;         % Rotacion local del joint 0
    rot3 = 0;         % Rotacion local del joint 0

    skeleton = [trans0; trans1; trans2; trans3];
    rots = [rot1 rot2 rot3];

    figure;
    hold on;
    grid on;
    axis equal;
    xlim([-5 5]);
    ylim([-5 5]);

    plot_skeleton(skeleton, rots); % Acaba de desarrollar esta función

    hold off;
end
</pre>
<pre class="matlab-code">

function plot_skeleton(skeleton, rots)
    rot1 = rots(1);
    rot2 = rots(2);
    rot3 = rots(3);
    % Aplicamos nodo 0

    rot0_matrix = [ 1 0 0;
    0 1 0;
    0 0 1];

    trans0_matrix = [1 0 skeleton(1,1);
    0 1 skeleton(1,2);
    0 0 1];

    pos             = rot0_matrix * trans0_matrix;
    scatter(pos(1,3), pos(2,3),300,'o','filled');

    % Aplicamos nodo 1
    rot1_matrix = [ +cosd(rot1) -sind(rot1) 0;
    +sind(rot1) +cosd(rot1) 0;
    0          0          1 ];

    trans1_matrix = [1 0 skeleton(2,1);
    0 1 skeleton(2,2);
    0 0 1];

    old_pos = pos;
    pos     =   rot0_matrix * trans0_matrix ...
    * rot1_matrix * trans1_matrix ;

    scatter(pos(1,3), pos(2,3),300,'o','filled');
    line([pos(1,3),old_pos(1,3)],[pos(2,3),old_pos(2,3)], 'LineWidth', 2);

    % Desarrolla el código para pintar el resto de la cadena

end
</pre>
            </p>
            <h2>Ejercicio 2.1.2</h2>
            <p>
            Cambia los valores de los parámetros del vector <code>rots</code> y observa como cambia la posición de la cadena. Consigue articulaciones parecidas a estas: <a href="images/2_1_2/0.png"/>ejemplo1</a>, <a href="images/2_1_2/1.png"/>ejemplo2</a>, <a href="images/2_1_2/2.png"/>ejemplo3</a>, <a href="images/2_1_2/3.png"/>ejemplo4</a>. Asegúrate de entender cómo afectan los cambios de cada uno de los parámetros en el estado final de la cadena.
            </p>
            <h2>Ejercicio 2.1.3</h2>
            <p>
            Añade dos eslabones más en la estructura jeráquica del ejercicio anterior.
            </p>
            </div>

            <div class="section head">
                <h1>Tema 2.1 — Cinemática inversa</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 2.2.1 — <font color="red">Entrega el 1 de Diciembre 2016</font></h2>
                <p>
                Desarrolla una función de Cinemática Inversa <code>run_IK()</code> que, dado una cadena jerárquica en reposo (vector de desplazamientos en 2D) y un objetivo (una coordenada 2D), calcule el valor de cada uno de los ángulos del cadena de tal forma que el <i>end effector</i> (punta de la cadena) este lo más cerca posible al objetivo. Para ello, utiliza la técnica del Jacobiano explicada en clase, y visualiza en MATLAB cada una de las iteraciones.</p>
                <p><a href="images/2_2_1/IK.gif"><b>Aquí</b></a> tienes una animación de cómo debería ser el resultado</p>
                    <p> Recuerda que la parte principal de la función <code>run_IK</code> es un bucle de este estilo.</p>

<pre class="matlab-code">
while(error(current_position, target) > 0.1)
    % Dibuja el estado actual
    plot_skeleton(skeleton, rots)
    drawnow;

    % Calcula Jacobiano del estado actual
    J = compute_jacobian(skeleton, rots);

    % Calcula posicion actual del end effector
    current_position = compute_position(skeleton, rots);

    % Calcula incrementos de las rotaciones
    update = ... ;

    % Actualiza rotaciones
    rots(1) = rots(1) + update(1);
    rots(2) = rots(2) + update(2);
    rots(3) = rots(3) + update(3);
end
</pre>
</p>
            </div>
 <!--
<div class="section acknowledgments">
<h2>Acknowledgments</h2>
  -->
<div class="section">
<hr class="smooth">
Animación por Computador, 2016 — Dan Casas
</div>
</div>
</div>


</body>
</html>
