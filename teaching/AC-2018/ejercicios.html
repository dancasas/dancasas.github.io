
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    
    
    <head>
        <title>Animación por Computador — Tema 1</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
            
         <!-- Fonts and stuff -->
         <link href="matlab-highlighter-1.55.css" rel="stylesheet" type="text/css">
         <script src="matlab-highlighter-1.55.min.js"></script>
         <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,800italic,400,700,800" rel='stylesheet' type='text/css'>
         <link rel="stylesheet" type="text/css" href="style.css" media="screen"/>
                
        </head>
                
        <body onload="highlightMATLABCode();">
            <div id="content">
            <div id="content-inner">
                
                <div class="section head">
                    <h1>Slides</h1>
                </div>
                <div class="section abstract" >
                    1.1 — <a href="docs/1.1-Interpolacion-v2018.pdf">Interpolación </a><br/>
                    1.2 — <a href="docs/1.2-Movimiento-a-traves-de-una-curva-v2018.pdf">Movimiento a través de una curva </a><br/>
                    1.3 — <a href="docs/1.3-Sistemas-Keyframe-v2018.pdf">Sistemas keyframe </a><br/>
                    
                    1.4 — <a href="docs/1.4-Deformacion-de-objetos-v2018.pdf">Deformación de objetos</a><br/>
                    <br/>
                    2.1 — <a href="docs/2.1-Cinematica-directa-v2018.pdf">Cinemática directa</a><br/>
                    <!--
                    2.2 — <a href="docs/2.2-Cinematica-inversa-v2017.pdf">Cinemática inversa</a><br/>
                    <br/>
                    3.1 — <a href="docs/3.1-Animacion-humana-v2017.pdf">Animación Humana</a><br/>
                    3.2 — <a href="docs/3.2-Animacion-facial-v2017.pdf">Animación Facial</a><br/>
                    3.3 — <a href="docs/3.3-Cloth-v2017.pdf">Cloth Simulation</a><br/><br/>
                    <br/>
                    -->
                </div>
            <div class="section head">
                <h1>Tema 1.1 — Interpolación</h1>
                
                <div class="authors">
                Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                <div class="venue"></div>
                
            </div>
            <!--
            <div class="section teaser">
            <iframe width="640" height="360" src="https://www.youtube.com/embed/?" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
            <p style="font-size:11px; text-align:center">
            <a href="content/>.mp4" target="_blank">Download Video</a>
            </p>
            </div>
            -->
        
            <div class="section abstract" >
                <h2>Ejercicio 1.1.1</h2>
                <p>
                    Escribe una función de MATLAB para visualizar los polinomios base de Hermite de grado 3.
                    <pre class="matlab-code">
function plot_hermite_basis()
    figure;
    hold on;
    grid on;
                
    % Rango
    x = 0:0.0001:1;
                
    H0 = 2*x.^3 - 3*x.^2 +1 ;
    plot(x,H0);

    % Completar...
    
    hold off;
end                    </pre>
                
<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="https://www.dropbox.com/s/6vo8ukmq66a23n3/plot_hermite_basis.m">Solución</a>

                </p>
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.1.2</h2>
                <p>
                Calcula el polinomio de Hermite <code>P(x)</code> tal que <code>P(0) = 1</code>, <code>P(1) = 1</code>, <code>P'(0) = 0</code>, <code>P'(1) = 1</code>. Implementa una función en MATLAB para visualizar el resultado.
                    <pre class="matlab-code">
function hermite_interpolation_demo()
    figure;
    hold on;
                    
    % Completar ...
                    
    plot(x,y);
    hold off;
end</pre>
 
<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="https://www.dropbox.com/s/x4t74pj8zg5b6im/hermite_interpolation_demo.m">Solución</a>             

                </p>
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 1.1.3</h2>
                <p>
                Calcula el polinomio interpolador de Lagrange de la siguiente tabla. Escribe una función de MATLAB que dibuje cada uno de los polinomios interpoladores y el polinomio resultante.
                </p>
                
                <code>
                    x -9  -4  -1   7<br/>
                    y  5   2  -2   9<br/>
                </code>
                <br/>
                <p>
                El resultado debe ser algo parecido a <a href="ejercicio3.png">esto</a>.
                
                
                ¿Cuál es el valor del primer polinomio interpolador en <code>x=-4</code>, <code>x=-1</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del segundo polinomio interpolador en <code>x=-9</code>, <code>x=-1</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del tercer polinomio interpolador en <code>x=-9</code>, <code>x=-4</code> y <code>x=7</code>?
                
                ¿Cuál es el valor del cuarto polinomio interpolador en <code>x=-9</code>, <code>x=-4</code> y <code>x=-1</code>?
                <br/><br/>
                 
                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="https://www.dropbox.com/s/yo9drccjx7ou7fc/lagrange_interpolation_demo.m">Solución</a>

                </p>
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.1.4</h2>
                <p>
                Interpolar y dibujar en MATLAB con splines lineales la función <code>f(x) = 1 / x</code> en los puntos en los que  <code>x</code> vale <code>1, 2 y 4</code>.
                <br/><br/>
                
                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="https://www.dropbox.com/s/qxm5tbs6djyj63s/linear_spline_interpolation.m">Solución</a>
		
                </p>
                
            </div>

            <div class="section abstract" >
                <h2>Ejercicio 1.1.5</h2>
                <p>
                Interpolar y dibujar en MATLAB  con splines quadráticas (grado 2) la función <code>f(x)</code> que pasa por los puntos <code>f(3) = 2.5; f(4.5) = 1;  f(7) = 2.5; f(9)=0.5</code>. Utiliza la función de MATLAB <code>X = linsolve(A,b)</code> o el operador <code>X = A\b</code> para resolver el sistema de ecuaciones.
                <br/><br/>
                Se trata de un sistema indeterminado, con más incognitas que ecuaciones. ¿Qué se puede hacer en estos casos? Calcula por lo menos 2 posibles soluciones del sistema, y dibuja las splines resultantes en MATLAB.
                <br/><br/>

                <img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="https://www.dropbox.com/s/xf0wbystgwb5qdi/quadratic_spline_interpolation.m">Solución</a>

                </p>
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 1.1.6</h2>
                <p>
                Utilizando como referencia la función <code>bezier_linear()</code> de más abajo que dibuja una <curva> de Bezier de con sólo dos puntos de control, escribe dos nuevas funciones <code>bezier_quadratic()</code> y <code>bezier_cubic()</code> que calculen y dibujen curvas cuadráticas y cúbicas.
                    <br/>
                    <br/>
                    Modifica el tercer parámetro de la función <code>linspace</code> y observa como cambian las curvas dibujadas. ¿Qué controla este parámetro?
                <pre class="matlab-code">
function placelabel(pt,str)
    x = pt(1);
    y = pt(2);
    h = line(x,y);
    h.Marker = '*';
    h = text(x,y,str);

    h.HorizontalAlignment = 'center';
    h.VerticalAlignment = 'bottom';
end
                </pre>
                
<pre class="matlab-code">
function bezier_linear()
    figure;
    hold on
    pt1 = [ 5;-10];
    pt2 = [45; 15];

    placelabel(pt1,'  pt_1');
    placelabel(pt2,'  pt_2');
    xlim([0 50])
    axis equal

    % Crea un vector de 100 valores equidistantes entre 0 y 1
    t = linspace(0,1,100);
    % Evalua la funcion (1-t) * pt1 + t * pt2 en todos los puntos t
    pts = kron((1-t),pt1) + kron(t,pt2);

    % Metodo alternativo
    %pts = [];
    %for t=0:0.2:1
    %    pts = [pts ((1-t) * pt1 + t * pt2)];
    %end

    plot(pts(1,:), pts(2,:));

    hold off;
end
</pre>
                </p>
                
            </div>
             
            <div class="section head">
                <h1>Tema 1.2 — Movimiento a través de una curva</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            
            <div class="section abstract" >
                <h2>Ejercicio 1.2.1 – <font color="red">Entrega el 8 de Octubre 2018, 23:59</font> </h2>
                <p>
                Escribe una funcion en MATLAB llamada <code>compute_arc_length_cubic_bezier(pt1, pt2, pt3, pt4, samples)</code> que calcule mediante <i>Forward Differencing</i> la longitud del arco de una curva cúbica de Bezier. ¿Cómo cambia el resultado en función del parámetro <code>samples</code>?
                <br/><br/>
                
                    <!--<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="#">Solución</a>-->
                
                </p>
                
                <h2>Ejercicio 1.2.2 – <font color="red">Entrega el 8 de Octubre 2018, 23:59</font></h2>
                <p>
                Escribe una función en MATLAB que dados 4 puntos de control, calcule su curva de Bezier y marque sobre ella: puntos equidistantes con respecto el parámetro <code>t</code> (tiempo) y con respecto el parámetro <code>s</code> (longitud del arco). El resultado final debería ser parecido a <b><a href="trivial-VS-constant.png">esto</a></b>.
                
                <br/><br/>
                
                    <!--<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="#">Solución</a>-->
                
                </p>
                

                <h2>Ejercicio 1.2.3 – <font color="red">Entrega el 8 de Octubre 2018, 23:59</font></h2>
                <p>
                Dibuja en MATLAB un curva cerrada con continuidad C<sup>1</sup> creada por 4 curvas cúbicas de Bezier. Utiliza transformaciones del tipo translación y escalado en los puntos de control para cambiar el tamaño la curva dibujada. <b><a href="bezier-joint.png">Aquí</a></b> tienes un ejemplo del tipo de resultado que puedes conseguir.
                
                <br/><br/>
                
                    <!--<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="#">Solución</a>-->
                </p>
                
                <h2>Ejercicio 1.2.4 – <font color="red">Entrega el 8 de Octubre 2018, 23:59</font></h2>
                <p>
                Crea una imagen en la que aparezca una letra cualquiera (<a href="https://www.dropbox.com/s/um959pf2q42grdf/d.jpg">ejemplo</a>), y cárgala como imagen de fondo de un <code>figure</code> como se hace en el principio de la función <code>function bezier_over_letter()</code> que se muestra a continuación. Completa el resto de la función de manera que la silueta de la letra se aproxime mediante curvas de Bezier cúbicas.

                Una vez tengas todas curvas necesarias, escálalas para obtener la misma letra más grande y más pequeña.
                </p>
                <pre class="matlab-code">
function bezier_over_letter()
    cla

    img = imread('d.jpg'); %  actualizar path a imagen
    image('CData',img,'XData',[-100 100],'YData',[100 -100])

    xlim([-100 100])
    ylim([-100 100])

    axis equal
    grid on;
    hold on;

    % completar

    hold off;
end

                </pre>
                <br/>
                
                    <!--<img src="images/check.png" style="width:0.8em; height:0.8em;"><a href="#">Solución</a>-->
                </p>
            </div>
        
            
            <div class="section head">
                <h1>Tema 2.1 — Cinemática directa</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 2.1.1</h2>
                <p>
Desarrolla la función <code>plot_skeleton(skeleton, rots) </code>en MATLAB que dibuje mediante la técnica de Cinemática Directa la estructura jerárquica inicializada a continuación.
            </p>
<pre class="matlab-code">
function skeleton_demo()
    close all;

    trans0 = [0,0];
    trans1 = [-1,-1]; % Offset con respecto joint 0
    trans2 = [0,-1];  % Offset con respecto joint 1
    trans3 = [0,-1];  % Offset con respecto joint 2

    rot1 = 0;         % Rotacion local del joint 0
    rot2 = 0;         % Rotacion local del joint 0
    rot3 = 0;         % Rotacion local del joint 0

    skeleton = [trans0; trans1; trans2; trans3];
    rots = [rot1 rot2 rot3];

    figure;
    hold on;
    grid on;
    axis equal;
    xlim([-5 5]);
    ylim([-5 5]);

    plot_skeleton(skeleton, rots); % Acaba de desarrollar esta función

    hold off;
end
</pre>
<pre class="matlab-code">

function plot_skeleton(skeleton, rots)
    rot1 = rots(1);
    rot2 = rots(2);
    rot3 = rots(3);
    % Aplicamos nodo 0

    rot0_matrix = [ 1 0 0;
    0 1 0;
    0 0 1];

    trans0_matrix = [1 0 skeleton(1,1);
                     0 1 skeleton(1,2);
                     0 0 1];

    pos             = rot0_matrix * trans0_matrix;
    scatter(pos(1,3), pos(2,3),300,'o','filled');

    % Aplicamos nodo 1
    rot1_matrix = [ +cosd(rot1) -sind(rot1) 0;
                    +sind(rot1) +cosd(rot1) 0;
                     0          0          1 ];

    trans1_matrix = [1 0 skeleton(2,1);
                     0 1 skeleton(2,2);
                     0 0 1];

    old_pos = pos;
    pos     =   rot0_matrix * trans0_matrix ...
    * rot1_matrix * trans1_matrix ;

    scatter(pos(1,3), pos(2,3),300,'o','filled');
    line([pos(1,3),old_pos(1,3)],[pos(2,3),old_pos(2,3)], 'LineWidth', 2);

    % Desarrolla el código para pintar el resto de la cadena

end
</pre><!--
            <h2>Ejercicio 2.1.2</h2>
            <p>
            Cambia los valores de los parámetros del vector <code>rots</code> y observa como cambia la posición de la cadena. Consigue articulaciones parecidas a estas: <a href="images/2_1_2/0.png">ejemplo1</a>, <a href="images/2_1_2/1.png">ejemplo2</a>, <a href="images/2_1_2/2.png">ejemplo3</a>, <a href="images/2_1_2/3.png">ejemplo4</a>. Asegúrate de entender cómo afectan los cambios de cada uno de los parámetros en el estado final de la cadena.
            </p>
            <h2>Ejercicio 2.1.3</h2>
            <p>
            Añade dos eslabones más en la estructura jeráquica del ejercicio anterior.
            </p>
            </div>
        -->
<!--
            <div class="section head">
                <h1>Tema 2.2 — Cinemática inversa</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                
                
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 2.2.1 — <font color="red">Entrega el 3 de Diciembre 2017</font></h2>
                <p>
                Desarrolla una función de Cinemática Inversa <code>run_IK()</code> que, dado una cadena jerárquica en reposo (vector de desplazamientos en 2D) y un objetivo (una coordenada 2D), calcule el valor de cada uno de los ángulos del cadena de tal forma que el <i>end effector</i> (punta de la cadena) este lo más cerca posible al objetivo. Para ello, utiliza la técnica del Jacobiano explicada en clase, y visualiza en MATLAB cada una de las iteraciones.</p>
                <p><a href="images/2_2_1/IK.gif"><b>Aquí</b></a> tienes una animación de cómo debería ser el resultado</p>
                    <p> Recuerda que la parte principal de la función <code>run_IK</code> es un bucle de este estilo.</p>

<pre class="matlab-code">
while(error(current_position, target) > 0.1)
    % Dibuja el estado actual
    plot_skeleton(skeleton, rots)
    drawnow;

    % Calcula Jacobiano del estado actual
    J = compute_jacobian(skeleton, rots);

    % Calcula posicion actual del end effector
    
    % Calcula incrementos de las rotaciones

    % Actualiza rotaciones

end
</pre>
            </div>

        -->
 <!--
            <div class="section head">
                <h1>Tema 3.1 — Caminar</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                            
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 3.1.1</h2>
                <p>
                    Descárgate <a href="images/3_1_1/dummy.bvh">este archivo BVH</a> que contiene el esqueleto báisco. Importalo a Blender. Edítalo con un editor de texto para crear alguna animación sencilla, por ejemplo:
                </p>
                <ol>
                    <li>Añade un movimiento translacional al nodo root durante 10 frames.</li>
                    <li>Añade un movimiento rotacional en alguno de sus articulaciones durante 10 frames.</li>
                    <li>Añade un eslabón nuevo a su cuerpo en reposo, con 2 DOFs.</li>
                </ol>
                <p>
                    <a href="images/3_1_1/ex1.gif">Aquí</a> tienes una sencilla animación de lo que tienes que conseguir.
                </p>
                <h2>Ejercicio 3.1.2</h2>
                <p>
                Edita el archivo del ejercicio anterior, y cambia las línias del tipo <code>CHANNELS 3 Xrotation Yrotation Zrotation</code> por <code>CHANNELS 3 Zrotation Xrotation Yrotation</code>. ¿Puedes adivinar qué es lo que estás cambiando? ¿Qué consecuencuas tiene en la animación resultante? 
                </p>         
                <h2>Ejercicio 3.1.3</h2>
                <p>
                    Descárgate <a href="images/3_1_3/human-motion-start.blend">esta escena de Blender</a> y fíjate en las curvas de valores cómo la translación y la rotación de la pelvis (nodo root). Debería parecerse a <a href="images/3_1_3/curvas-rotacion-pelvis.png">esto</a>, que coincide con los gráficos correspondientes a la acción de caminar como hemos visto en clase. Intenta modificar las curvas en el Editor de Curvas de Blender, y observa cómo cambia la animación.
                </p> 
            </div>
            
            <div class="section head">
                <h1>Tema 3.2 — Animación Facial</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                            
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 3.2.1</h2>
                <p>
                Descárgate <a href="https://www.dropbox.com/s/k7ubi8snpqeh39y/blendshapes.zip?dl=1">este zip</a> que contiene un set de <i>blendshapes</i>, descomprimelo y guárdalas en un directorio. Descárgate también la función para dibujar mallas en format OBJ <code><a href="images/3_2_1/read_vertices_and_faces_from_obj_file.m">read_vertices_and_faces_from_obj_file.m</a></code>.</p>
                <p>Acaba de implementar la función <code>compute_global_blendshapes()</code>, para que interpole entre 2 mallas utilizado el método de blendshape global que hemos visto en clase.</p>
<pre class="matlab-code">
function compute_global_blendshapes()
    close all
    
    % Path where you uncompress all .obj
    blendshape_path = '/Users/URJC/Downloads/tri' % ¡¡Actualiza el path!!
    
    % Read OBJ files
    [V00,F] = read_vertices_and_faces_from_obj_file(strcat(blendshape_path, '/neutral-tri.obj'));
    % V00 es una matrix vertices de tamaño [numero_vertices x 3]
    num_vertices = size(V00,1); % Lee número de vertices
    % Vectoriza malla 00
    V00 = vertcat(V00(:,1),V00(:,2),V00(:,3));
    
    % ¡¡¡¡Leer más OBJ aquí!!!!
    
    figure;

    %  Creamos un vector t con parametros alpha que utilizaremos
    t=0:0.2:1;
    t = [t flip(t)];
    iterations = 0;
    
    % Loop infinito para ver los resultados
    while 1
       
        % Iteración actual. Utilizamos módulo para siempre tener un número
        % de iteración > tamaño del vector de alphas t.
        iterations = mod(iterations,size(t,2)) + 1;

        % Alpha correspondiente a la iteración actial
        alpha = t(iterations);

        % Stores current viewpoint
        [az, el] = view; 

        % ¡¡¡¡Calcular blendshape!!!!
        V_blend = ...
        
        % Reshapes from vectorized mesh to [num_vertices,3]
        V_blend = reshape(V_blend,[num_vertices,3]);
        
        % Draws mesh
        trisurf(F,V_blend(:, 1),...
                  V_blend(:, 2),...
                  V_blend(:, 3),...
                  'FaceColor',[0.26,0.63,1.0 ],'EdgeColor','none','LineStyle','none','SpecularStrength',0.4);
      
        % Sets current viewpoint
        view (az, el);
       
        % Set up lighing
        light('Position',[-1.0,-1.0,100.0],'Style','infinite');
        lighting phong;
        
        % Set up axis
        axis equal
        axis([-1.5 1.5 0 2 -1 1.5])
       
        drawnow;
    end
end
</pre>
                <h2>Ejercicio 3.2.2</h2>
                <p>
                ¿Qué pasa cuándo asignamos una <i>alpha</i> mayor que 1, utilizando el método global de blendshapes?  
                </p> 
                <h2>Ejercicio 3.2.3</h2>
                <p>
                    Usando como referencia la función desarrollada en el ejercicio 3.2.1, implementa la función <code>compute_delta_blendshapes()</code> utilizando el método <i>delta blendshapes</i> presentado en clase. Mezcla <b>más</b> de 2 mallas a la vez. Por ejemplo, consigue una animación donde el personaje abra la boca y cierre los dos ojos. <a href="images/3_2_3/blendshape.gif">Aquí tienes una animación de lo que tienes que conseguir</a>.
                </p>
                <h2>Ejercicio 3.2.4</h2>
                <p>
                ¿Qué pasa cuándo asignamos una <i>alpha</i> mayor que 1, utilizando el método delta de blendshapes?  
                </p> 
                
            </div>
        -->
            <!--
            <div class="section head">
                <h1>Tema 3.3 — Cloth simulation</h1>
                
                <div class="authors">
                    Ejercicios
                </div>
                
                <div class="affiliations">
                </div>
                            
                <div class="venue"></div>
                
            </div>
            <div class="section abstract" >
                <h2>Ejercicio 3.2.1</h2>
                <p>
                    Descárgate <a href="https://www.dropbox.com/s/0uoxamli0smbqbm/cloth_simulation.blend?dl=1">esta</a> escena de Blender
                </p>    
            </div>
            -->
                
            <div class="section">
            <hr class="smooth">
            Animación por Computador, 2018 — Dan Casas
            </div>
        </div>
    </div>
</body>
</html>
